# Notes -  ideas - random


### A user path 
When user access my app: 
1. First step is that my app will goes to (/) route, and then
this route requires authorization,so redirects to /login.

2. Step two is login will redirect to authorization server which is KC.

3. After i am auth in (KC) i will (the user), redirect back to (/) 
which is displaying a plain html with a welcome message,
and a button to fetch resources from the microservise 
running on a different infrustructure.



////
starting at /5000

### Step 1: User Visits Login Page

**URL:**
```
http://localhost:8080/realms/news_books_realm/protocol/openid-connect/auth?response_type=code&client_id=news_books_client&redirect_uri=http%3A%2F%2Flocalhost%3A5000%2Fauthorize&scope=openid+email+profile&state=hqj9ldaSfEbnKV1ex0IlzYBHfPdwXo&nonce=Cp4JocrgYLV9ABT5yr4n
```

- **Issuer:** The web application running on `localhost:5000` redirects the user to the Keycloak server (`localhost:8080`), which handles authentication for the `news_books_realm`.
  
- **Purpose:** This URL initiates the OpenID Connect (OIDC) authentication process. The client (`news_books_client`) requests an authorization code (`response_type=code`). This code will be exchanged later for an access token. The `redirect_uri` parameter specifies where the user should be redirected after successful authentication, and `scope` defines the level of access (like `openid`, `email`, `profile`).

- **Expected Response:** Keycloak will prompt the user for credentials if they are not already logged in.

### Step 2: User Submits Credentials

The user enters credentials and clicks the "Login" button. This triggers a POST request to authenticate the user.

**URL:**
```
http://localhost:8080/realms/news_books_realm/login-actions/authenticate?session_code=CWFAG9GHwWonrOUWsambpsoK2ulWwCh2FjpMmEJ6pD0&execution=91191432-b396-4aa2-803d-1836c2a3c1a7&client_id=news_books_client&tab_id=4kTdWikXFKs&client_data=eyJydSI6Imh0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hdXRob3JpemUiLCJydCI6ImNvZGUiLCJzdCI6ImhxajlsZGFTZkVibktWMWV4MElsellCSGZQZHdYbyJ9
```

- **Issuer:** This request is sent by the browser to the Keycloak server at `localhost:8080`.

- **Purpose:** The purpose of this request is to authenticate the user. The payload includes `username`, `password`, and other session-related data like `session_code`, `execution`, and `client_id`. These parameters help Keycloak identify the ongoing authentication session and the specific client requesting authentication.

- **Expected Response:** If the credentials are correct, Keycloak will respond with a `302 Found` status code, redirecting the browser to the `redirect_uri` (which is the application at `localhost:5000`). This response also includes a temporary `code` that the application will exchange for tokens.

### Step 3: Redirect Back to Application with Authorization Code

After successful authentication, Keycloak redirects the user back to the client application with an authorization code.

**URL:**
```
http://localhost:5000/authorize?state=hqj9ldaSfEbnKV1ex0IlzYBHfPdwXo&session_state=deffcc11-5c20-4dc4-9d33-b792f1496549&iss=http%3A%2F%2Flocalhost%3A8080%2Frealms%2Fnews_books_realm&code=cc53a2ce-588d-48f5-a0f6-c173ce066af7.deffcc11-5c20-4dc4-9d33-b792f1496549.4939703e-8dce-4ea6-852b-21fd3dfaac69
```

- **Issuer:** This request is generated by Keycloak and sent to the client application running on `localhost:5000`.

- **Purpose:** The purpose of this request is to pass the authorization code (`code`) back to the client application. The client application will now use this code to request an access token from Keycloak.

- **Expected Response:** The client application at `localhost:5000` receives the code and then typically initiates a backend request to Keycloak to exchange the code for an access token, ID token, and possibly a refresh token.

### Step 4: Final Redirect and User Sees Welcome Page

**URL:**
```
http://localhost:5000/
```

- **Issuer:** The client application (running on `localhost:5000`) issues this request after handling the authorization code and possibly exchanging it for tokens.

- **Purpose:** This URL corresponds to the main page of the application, which is displayed after the user has successfully logged in. At this point, the application has verified the user’s identity using the tokens obtained from Keycloak.

- **Expected Response:** The application responds by rendering the welcome page, where the user might see personalized content (e.g., "Welcome, Mike").


### **Step 5: User Clicks "Fetch" Button and Requests Additional Resources**
- **URL:**
  ```
  http://localhost:5000/fetch_resources?
  ```
- **Request Method:** GET
- **Status Code:** 302 FOUND
- **Issuer:** The web application running on `localhost:5000` sends this request when the user clicks the "Fetch" button to retrieve additional resources from a microservice.
- **Purpose:** This request aims to fetch specific resources. However, the server responds with a `302 Found` status code, indicating a temporary redirect. This might happen due to a variety of reasons, such as the user not being authorized to access the resource directly or a need to process additional authentication.
- **Expected Response:** The server includes a `Location` header in the response, directing the client to a different URL, often signaling that further action is required before the resource can be accessed.

### **Step 6: Redirect to the Root URL Again After Resource Fetch**
- **URL:**
  ```
  http://localhost:5000/
  ```
- **Request Method:** GET
- **Status Code:** 200 OK
- **Issuer:** Following the `302 Found` redirect from the previous step, the browser automatically issues a new GET request to the URL specified in the `Location` header of the previous response, which in this case is the root URL again (`/`).
- **Purpose:** This step ensures the user is correctly redirected, possibly indicating a fallback mechanism or a re-validation step in the resource-fetching process.
- **Expected Response:** The server responds with the main HTML page or another resource depending on the application’s logic. The process might result in the display of a different page or reloading of the current page.


### **Overview of the Flow**

1. **Initial Login Request:** The user is directed from the application to the identity provider (Keycloak) to authenticate.
2. **Authentication:** Keycloak processes the login information and, upon success, generates an authorization code.
3. **Authorization Code Exchange:** The client application exchanges the authorization code for tokens, allowing it to manage user sessions securely.
4. **Main Application Page:** After successful authentication, the user is redirected back to the main application page, where they are now logged in.
5. **Fetching Resources:** The user initiates a resource fetch, which may involve further redirects or authentication checks.
6. **Final Redirect:** After the resource-fetching attempt, the user might be redirected back to the main page or another fallback URL, ensuring that the application flow remains consistent.




- Port binding ? 
docker run -p 5000:5000 -p 5001:5001 your_image_name

- see docker images
docker images 
docke image ls


1. List Running Containers
To view only the containers that are currently running:
docker ps

CONTAINER ID: The unique identifier for the container.
IMAGE: The image from which the container was created.
COMMAND: The command that was used to start the container.
CREATED: How long ago the container was created.
STATUS: The current status of the container.
PORTS: Ports exposed by the container.
NAMES: The names assigned to the container.


2. List All Containers
To view all containers, including those that are stopped:

docker ps -a

3. Inspect a Specific Container
To get detailed information about a specific container:

docker inspect <container_id>
Replace <container_id> with the actual ID or name of the container you want to inspect.

4. View Container Logs
To view logs for a specific container, which can be useful for debugging:

docker logs <container_id>
Replace <container_id> with the actual ID or name of the container.

5. View Resource Usage
To see the resource usage (CPU and memory) of your containers:

docker stats
This command provides a real-time stream of resource usage statistics for all running containers.


To go inside a Docker container and get a shell prompt, you can use the `docker exec` command. Here’s how you can do it:

### 1. **Using `docker exec` to Open a Shell**

#### **Get a Bash Shell**

If the container has `bash` installed, you can use:

```bash
docker exec -it <container_id_or_name> bash
```

#### **Get a Sh Shell**

If `bash` is not available, you can use `sh`, which is available in most containers:

```bash
docker exec -it <container_id_or_name> sh
```

### 2. **Detailed Steps**

1. **Find the Container ID or Name**

   First, you need to know the ID or name of the container you want to access. You can list all running containers with:

   ```bash
   docker ps
   ```

   This command will show you the container IDs and names.

2. **Access the Container**

   Once you have the container ID or name, use `docker exec` to start a shell session:

   ```bash
   docker exec -it <container_id_or_name> bash
   ```

   or

   ```bash
   docker exec -it <container_id_or_name> sh
   ```

   Here’s a breakdown of the flags used:
   - `-i` (interactive) keeps the STDIN open even if not attached.
   - `-t` (pseudo-TTY) allocates a terminal.

### Examples

#### **Accessing a Container with Bash**

If your container is named `my_container` and has `bash` installed:

```bash
docker exec -it my_container bash
```

#### **Accessing a Container with Sh**

If your container is named `my_container` but only has `sh`:

```bash
docker exec -it my_container sh
```

### Additional Tips

- **Exit the Shell**: To exit the container's shell, simply type `exit` and press Enter.

- **Running Commands**: You can also run a single command inside the container without starting an interactive shell. For example:

  ```bash
  docker exec -it <container_id_or_name> ls /app
  ```

  This runs the `ls /app` command inside the container and prints the output.

- **Different Users**: If you need to run the shell as a different user, you can specify the `-u` option:

  ```bash
  docker exec -it -u <username> <container_id_or_name> bash
  ```

By using `docker exec`, you can interact with your container’s filesystem and processes, which is useful for debugging, managing applications, or running maintenance tasks.




Trtansferring kc settings from original  to docker

- news_books_realm
  - Settings
    - Realm ID* : news_books_realm
      Display name : News and Books
      HTML Display name : 
      Frontend URL :  
      Require SSL :External requests

      User-managed access : Off
      Unmanaged Attributes : Disabled
      Endpoints 
      OpenID Endpoint Configuration 
      SAML 2.0 Identity Provider Metadata 

    - Login 
      - User registration : On
      - Login with email: On
      (All other off)
    
    - Email Nothing here

    - Themes Nothing here

    - Keys Nothing here

    - Events
      - Events listeners : jboss-logging
      - User events settings : Nothing here
      - Admin events settings : Nothing here
    
    - Localization (nothing here)

    - Security defenecs ,  - sessions nothing here


- i am changing the localhost to -> host.docker.internal
in ms.py in the kc api calls

in app.py where i am making api calls to kc

in client secrets issuer, auth_uri, userinfo_uri, and token_uri.

keep note on app.py:
    keycloak_base_logout_url = "http://172.17.0.1:8080/realms/news_books_realm/protocol/openid-connect/logout"


ps
stop
rm
build
run

worked by adding Pyjwt instead of jwt on dockerfile installations